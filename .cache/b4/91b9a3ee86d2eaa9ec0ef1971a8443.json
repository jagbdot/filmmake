{"id":"js/shader/vertex.glsl","dependencies":[{"name":"/Users/juan/filmmake/package.json","includedInParent":true,"mtime":1596354662487}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nuniform float angle;\\nuniform float progress;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying float vFrontShadow;\\n// varying float vBackShadow;\\n// varying float vProgress;\\n\\nuniform sampler2D texture1;\\nuniform sampler2D texture2;\\nuniform vec2 pixels;\\n\\nconst float pi = 3.1415925;\\n\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n  mat4 m = rotationMatrix(axis, angle);\\n  return (m * vec4(v, 1.0)).xyz;\\n}\\n\\nvoid main() {\\n  vUv = uv;\\n  float pi = 3.14159265359;\\n\\n  float finalAngle = angle - 0.*0.3*sin(progress*6.);\\n\\n  // @todo account for aspect ratio!!!\\n  vec3 newposition = position;\\n\\n  // float angle = pi/10.;\\n  float rad = 0.1;\\n  float rolls = 8.;\\n  // rot\\n  newposition = rotate(newposition - vec3(-.5,.5,0.), vec3(0.,0.,1.),-finalAngle) + vec3(-.5,.5,0.);\\n\\n  float offs = (newposition.x + 0.5)/(sin(finalAngle) + cos(finalAngle)) ; // -0.5..0.5 -> 0..1\\n  float tProgress = clamp( (progress - offs*0.99)/0.01 , 0.,1.);\\n\\n  // shadows\\n  vFrontShadow = clamp((progress - offs*0.95)/0.05,0.7,1.);\\n  // vBackShadow = 1. - clamp(abs((progress - offs*0.9)/0.1),0.,1.);\\n  // vProgress = clamp((progress - offs*0.95)/0.05,0.,1.);\\n\\n  \\n\\n  newposition.z =  rad + rad*(1. - offs/2.)*sin(-offs*rolls*pi - 0.5*pi);\\n  newposition.x =  - 0.5 + rad*(1. - offs/2.)*cos(-offs*rolls*pi + 0.5*pi);\\n  // // rot back\\n  newposition = rotate(newposition - vec3(-.5,.5,0.), vec3(0.,0.,1.),finalAngle) + vec3(-.5,.5,0.);\\n  // unroll\\n  newposition = rotate(newposition - vec3(-.5,0.5,rad), vec3(sin(finalAngle),cos(finalAngle),0.), -pi*progress*rolls);\\n  newposition +=  vec3(\\n    -.5 + progress*cos(finalAngle)*(sin(finalAngle) + cos(finalAngle)), \\n    0.5 - progress*sin(finalAngle)*(sin(finalAngle) + cos(finalAngle)),\\n    rad*(1.-progress/2.)\\n  );\\n\\n  // animation\\n  vec3 finalposition = mix(newposition,position,tProgress);\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(finalposition, 1.0 );\\n}\\n\\n\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/vertex.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/vertex.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/vertex.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/vertex.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/vertex.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":2691},"source":"js/shader/vertex.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/vertex.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nuniform float angle;\\nuniform float progress;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying float vFrontShadow;\\n// varying float vBackShadow;\\n// varying float vProgress;\\n\\nuniform sampler2D texture1;\\nuniform sampler2D texture2;\\nuniform vec2 pixels;\\n\\nconst float pi = 3.1415925;\\n\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n  mat4 m = rotationMatrix(axis, angle);\\n  return (m * vec4(v, 1.0)).xyz;\\n}\\n\\nvoid main() {\\n  vUv = uv;\\n  float pi = 3.14159265359;\\n\\n  float finalAngle = angle - 0.*0.3*sin(progress*6.);\\n\\n  // @todo account for aspect ratio!!!\\n  vec3 newposition = position;\\n\\n  // float angle = pi/10.;\\n  float rad = 0.1;\\n  float rolls = 8.;\\n  // rot\\n  newposition = rotate(newposition - vec3(-.5,.5,0.), vec3(0.,0.,1.),-finalAngle) + vec3(-.5,.5,0.);\\n\\n  float offs = (newposition.x + 0.5)/(sin(finalAngle) + cos(finalAngle)) ; // -0.5..0.5 -> 0..1\\n  float tProgress = clamp( (progress - offs*0.99)/0.01 , 0.,1.);\\n\\n  // shadows\\n  vFrontShadow = clamp((progress - offs*0.95)/0.05,0.7,1.);\\n  // vBackShadow = 1. - clamp(abs((progress - offs*0.9)/0.1),0.,1.);\\n  // vProgress = clamp((progress - offs*0.95)/0.05,0.,1.);\\n\\n  \\n\\n  newposition.z =  rad + rad*(1. - offs/2.)*sin(-offs*rolls*pi - 0.5*pi);\\n  newposition.x =  - 0.5 + rad*(1. - offs/2.)*cos(-offs*rolls*pi + 0.5*pi);\\n  // // rot back\\n  newposition = rotate(newposition - vec3(-.5,.5,0.), vec3(0.,0.,1.),finalAngle) + vec3(-.5,.5,0.);\\n  // unroll\\n  newposition = rotate(newposition - vec3(-.5,0.5,rad), vec3(sin(finalAngle),cos(finalAngle),0.), -pi*progress*rolls);\\n  newposition +=  vec3(\\n    -.5 + progress*cos(finalAngle)*(sin(finalAngle) + cos(finalAngle)), \\n    0.5 - progress*sin(finalAngle)*(sin(finalAngle) + cos(finalAngle)),\\n    rad*(1.-progress/2.)\\n  );\\n\\n  // animation\\n  vec3 finalposition = mix(newposition,position,tProgress);\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(finalposition, 1.0 );\\n}\\n\\n\";"},"lineCount":null}},"error":null,"hash":"36427ae599b9cc6ae49c23ade43047df","cacheData":{"env":{}}}