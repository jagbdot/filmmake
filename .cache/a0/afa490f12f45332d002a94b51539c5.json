{"id":"QdeU","dependencies":[{"name":"/Users/juan/filmmake/package.json","includedInParent":true,"mtime":1596354662487},{"name":"fontfaceobserver","loc":{"line":1,"column":29},"parent":"/Users/juan/filmmake/js/app.js","resolved":"/Users/juan/filmmake/node_modules/fontfaceobserver/fontfaceobserver.standalone.js"},{"name":"./imagesLoaded","loc":{"line":2,"column":25},"parent":"/Users/juan/filmmake/js/app.js","resolved":"/Users/juan/filmmake/js/imagesLoaded.js"},{"name":"./rolls","loc":{"line":3,"column":18},"parent":"/Users/juan/filmmake/js/app.js","resolved":"/Users/juan/filmmake/js/rolls.js"},{"name":"gsap","loc":{"line":4,"column":17},"parent":"/Users/juan/filmmake/js/app.js","resolved":"/Users/juan/filmmake/node_modules/gsap/index.js"}],"generated":{"js":"\"use strict\";\n\nvar _fontfaceobserver = _interopRequireDefault(require(\"fontfaceobserver\"));\n\nvar _imagesLoaded = _interopRequireDefault(require(\"./imagesLoaded\"));\n\nvar _rolls = _interopRequireDefault(require(\"./rolls\"));\n\nvar _gsap = _interopRequireDefault(require(\"gsap\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar scene = new _rolls.default(\"container\"); // helper functions\n\nvar MathUtils = {\n  // map number x from range [a, b] to [c, d]\n  map: function map(x, a, b, c, d) {\n    return (x - a) * (d - c) / (b - a) + c;\n  },\n  // linear interpolation\n  lerp: function lerp(a, b, n) {\n    return (1 - n) * a + n * b;\n  }\n}; // body element\n\nvar body = document.body;\nvar IMAGES; // calculate the viewport size\n\nvar winsize;\n\nvar calcWinsize = function calcWinsize() {\n  return winsize = {\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n};\n\ncalcWinsize(); // and recalculate on resize\n\nwindow.addEventListener(\"resize\", calcWinsize);\n\nwindow.onbeforeunload = function () {\n  window.scrollTo(0, 0);\n}; // scroll position and update function\n\n\nvar docScroll;\n\nvar getPageYScroll = function getPageYScroll() {\n  return docScroll = window.pageYOffset || document.documentElement.scrollTop;\n};\n\nwindow.addEventListener(\"scroll\", getPageYScroll); // Item\n\nvar Item = /*#__PURE__*/function () {\n  function Item(el, scroll) {\n    var _this = this;\n\n    _classCallCheck(this, Item);\n\n    // the .item element\n    this.scroll = scroll;\n    this.DOM = {\n      el: el.img\n    };\n    this.currentScroll = docScroll;\n    this.animated = false;\n    this.isBeingAnimatedNow = false;\n    this.shouldRollBack = false;\n    this.shouldUnRoll = false;\n    this.positions = []; // set the initial values\n\n    this.getSize();\n    this.mesh = scene.createMesh({\n      width: this.width,\n      height: this.height,\n      src: this.src,\n      image: this.DOM.el,\n      iWidth: this.DOM.el.width,\n      iHeight: this.DOM.el.height\n    });\n    scene.scene.add(this.mesh); // use the IntersectionObserver API to check when the element is inside the viewport\n    // only then the element translation will be updated\n\n    this.intersectionRatio;\n    var options = {\n      root: null,\n      rootMargin: \"0px\",\n      threshold: [0, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n    };\n    this.observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        _this.positions.push(entry.boundingClientRect.y);\n\n        var compareArray = _this.positions.slice(_this.positions.length - 2, _this.positions.length);\n\n        var down = compareArray[0] > compareArray[1] ? true : false;\n        _this.isVisible = entry.intersectionRatio > 0.0;\n        _this.shouldRollBack = false;\n        _this.shouldUnRoll = false;\n\n        if (entry.intersectionRatio < 0.5 && entry.boundingClientRect.y > 0 && _this.isVisible && !down) {\n          _this.shouldRollBack = true;\n        }\n\n        if (entry.intersectionRatio > 0.5 && entry.boundingClientRect.y > 0 && _this.isVisible) {\n          _this.shouldUnRoll = true;\n        }\n\n        _this.mesh.visible = _this.isVisible;\n      });\n    }, options);\n    this.observer.observe(this.DOM.el); // init/bind events\n\n    window.addEventListener(\"resize\", function () {\n      return _this.resize();\n    });\n    this.render(0);\n  }\n\n  _createClass(Item, [{\n    key: \"getSize\",\n    value: function getSize() {\n      // get all the sizes here, bounds and all\n      var bounds = this.DOM.el.getBoundingClientRect();\n      var fromTop = bounds.top;\n      var windowHeight = window.innerHeight;\n      var withoutHeight = fromTop - windowHeight;\n      var withHeight = fromTop + bounds.height;\n      this.insideTop = withoutHeight - docScroll;\n      this.insideRealTop = fromTop + docScroll;\n      this.insideBottom = withHeight - docScroll + 50;\n      this.width = bounds.width;\n      this.height = bounds.height;\n      this.left = bounds.left;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      // on resize rest sizes and update the translation value\n      this.getSize();\n      this.mesh.scale.set(this.width, this.height, 200);\n      this.render(this.scroll.renderedStyles.translationY.current);\n      this.scroll.shouldRender = true;\n    }\n  }, {\n    key: \"render\",\n    value: function render(currentScroll) {\n      var _this2 = this;\n\n      this.currentScroll = currentScroll;\n      this.mesh.position.y = currentScroll + winsize.height / 2 - this.insideRealTop - this.height / 2;\n      this.mesh.position.x = 0 - winsize.width / 2 + this.left + this.width / 2;\n\n      if (this.shouldUnRoll && !this.animated) {\n        this.animated = true;\n        this.isBeingAnimatedNow = true;\n        this.shouldUnRoll = false;\n\n        _gsap.default.to(this.mesh.material.uniforms.progress, {\n          duration: 1.7,\n          value: 1,\n          ease: \"power2.out\",\n          onUpdate: function onUpdate() {\n            _this2.scroll.shouldRender = true;\n          },\n          onComplete: function onComplete() {\n            _this2.isBeingAnimatedNow = false;\n          }\n        });\n      }\n\n      if (this.shouldRollBack && this.animated) {\n        this.animated = false;\n        this.isBeingAnimatedNow = true;\n        this.shouldRollBack = false;\n\n        _gsap.default.to(this.mesh.material.uniforms.progress, {\n          duration: 1.7,\n          value: 0,\n          ease: \"power2.inOut\",\n          onUpdate: function onUpdate() {\n            _this2.scroll.shouldRender = true;\n          },\n          onComplete: function onComplete() {\n            _this2.isBeingAnimatedNow = false;\n          }\n        });\n      }\n    }\n  }]);\n\n  return Item;\n}(); // SmoothScroll\n\n\nvar SmoothScroll = /*#__PURE__*/function () {\n  function SmoothScroll() {\n    var _this3 = this;\n\n    _classCallCheck(this, SmoothScroll);\n\n    this.shouldRender = false; // the <main> element\n\n    this.DOM = {\n      main: document.querySelector(\"main\")\n    }; // the scrollable element\n    // we translate this element when scrolling (y-axis)\n\n    this.DOM.scrollable = this.DOM.main.querySelector(\"div[data-scroll]\"); // the items on the page\n\n    this.items = [];\n    this.createItems(); // here we define which property will change as we scroll the page\n    // in this case we will be translating on the y-axis\n    // we interpolate between the previous and current value to achieve the smooth scrolling effect\n\n    this.renderedStyles = {\n      translationY: {\n        // interpolated value\n        previous: 0,\n        // current value\n        current: 0,\n        // amount to interpolate\n        ease: 0.1,\n        // current value setter\n        // in this case the value of the translation will be the same like the document scroll\n        setValue: function setValue() {\n          return docScroll;\n        }\n      }\n    }; // set the body's height\n\n    this.setSize(); // set the initial values\n\n    this.update(); // the <main> element's style needs to be modified\n\n    this.style(); // init/bind events\n\n    this.initEvents();\n    this.buttons(); // start the render loop\n\n    requestAnimationFrame(function () {\n      return _this3.render();\n    });\n  }\n\n  _createClass(SmoothScroll, [{\n    key: \"buttons\",\n    value: function buttons() {\n      var _this4 = this;\n\n      var that = this;\n\n      var buttons = _toConsumableArray(document.querySelectorAll(\".js-change\"));\n\n      buttons.forEach(function (b) {\n        var angle = b.getAttribute(\"data-angle\");\n        var radians = angle * Math.PI / 180;\n        b.addEventListener(\"click\", function () {\n          scene.settings.angle = radians;\n          scene.scene.children.forEach(function (mesh) {\n            _gsap.default.fromTo(mesh.material.uniforms.progress, {\n              value: 0\n            }, {\n              duration: 2,\n              value: 1,\n              ease: \"power2.out\",\n              onUpdate: function onUpdate() {\n                _this4.shouldRender = true;\n              }\n            });\n          });\n        });\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // sets the initial value (no interpolation) - translate the scroll value\n      for (var key in this.renderedStyles) {\n        this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();\n      } // translate the scrollable element\n\n\n      this.setPosition();\n      this.shouldRender = true;\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition() {\n      // translates the scrollable element\n      if (Math.round(this.renderedStyles.translationY.previous) !== Math.round(this.renderedStyles.translationY.current) || this.renderedStyles.translationY.previous < 10) {\n        this.shouldRender = true;\n        this.DOM.scrollable.style.transform = \"translate3d(0,\".concat(-1 * this.renderedStyles.translationY.previous, \"px,0)\"); // console.log(this.items);\n\n        var _iterator = _createForOfIteratorHelper(this.items),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var item = _step.value;\n\n            // if the item is inside the viewport call it's render function\n            // this will update the item's inner image translation, based on the document scroll value and the item's position on the viewport\n            if (item.isVisible || item.isBeingAnimatedNow) {\n              item.render(this.renderedStyles.translationY.previous);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (this.shouldRender) {\n        this.shouldRender = false;\n        scene.render();\n      }\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize() {\n      // set the heigh of the body in order to keep the scrollbar on the page\n      // console.log(this.DOM.scrollable.scrollHeight, 'HEIGHT');\n      body.style.height = \"\".concat(this.DOM.scrollable.scrollHeight, \"px\");\n    }\n  }, {\n    key: \"createItems\",\n    value: function createItems() {\n      var _this5 = this;\n\n      IMAGES.forEach(function (image) {\n        if (image.img.classList.contains(\"js-image\")) {\n          _this5.items.push(new Item(image, _this5));\n        }\n      });\n    }\n  }, {\n    key: \"style\",\n    value: function style() {\n      // the <main> needs to \"stick\" to the screen and not scroll\n      // for that we set it to position fixed and overflow hidden\n      this.DOM.main.style.position = \"fixed\";\n      this.DOM.main.style.width = this.DOM.main.style.height = \"100%\";\n      this.DOM.main.style.top = this.DOM.main.style.left = 0;\n      this.DOM.main.style.overflow = \"hidden\";\n    }\n  }, {\n    key: \"initEvents\",\n    value: function initEvents() {\n      var _this6 = this;\n\n      // on resize reset the body's height\n      window.addEventListener(\"resize\", function () {\n        return _this6.setSize();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this7 = this;\n\n      // update the current and interpolated values\n      for (var key in this.renderedStyles) {\n        this.renderedStyles[key].current = this.renderedStyles[key].setValue();\n        this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);\n      } // and translate the scrollable element\n\n\n      this.setPosition(); // loop..\n\n      requestAnimationFrame(function () {\n        return _this7.render();\n      });\n    }\n  }]);\n\n  return SmoothScroll;\n}();\n/***********************************/\n\n/********** Preload stuff **********/\n\n\nvar fontParalucent = new Promise(function (resolve) {\n  new _fontfaceobserver.default(\"paralucent\").load().then(function () {\n    resolve();\n  });\n});\nvar fontStarling = new Promise(function (resolve) {\n  new _fontfaceobserver.default(\"starling\").load().then(function () {\n    resolve();\n  });\n}); // Preload images\n\nvar preloadImages = new Promise(function (resolve, reject) {\n  (0, _imagesLoaded.default)(document.querySelectorAll(\"img\"), {\n    background: true\n  }, resolve);\n});\npreloadImages.then(function (images) {\n  IMAGES = images.images;\n});\nvar preloadEverything = [fontStarling, fontParalucent, preloadImages]; // And then..\n\nPromise.all(preloadEverything).then(function () {\n  // Remove the loader\n  document.body.classList.remove(\"loading\");\n  document.body.classList.add(\"loaded\"); // Get the scroll position\n\n  getPageYScroll(); // Initialize the Smooth Scrolling\n\n  new SmoothScroll();\n});"},"sourceMaps":null,"error":null,"hash":"09b28c5b1f2ae7e552b12fd9b38140a2","cacheData":{"env":{}}}